#!/bin/bash
#
# Merge a branch and push it to its remote, where the branch being merged is
# for a GitHub Pull Request (PR).
#
# GitHub allows you to push a merge commit on a branch even when that branch is
# protected, if that commit is the result of merging a PR and that PR is
# suitable to be merged (all required checks have been satisfied, the required
# number of approvals are present, the branch it up-to-date WRT the target
# branch, etc). This feature allows you to operate from the command line
# instead of needing to use the GitHub web-ui to close a PR.
#
# Usage: git pr-merge
#
# Merges the current "feature" branch into the base "master" branch specified
# on the PR for the current branch.
#
# This scripts relies on the github `hub` tool to retrieve information about
# the merge branch PR. It will fail if not installed. Install it from
# https://github.com/github/hub.

main() {
  set -e
  set -u
  set -o pipefail

  prmerge::read_config
  prmerge::setup "$@"
  prmerge::prepare
  prmerge::merge
  prmerge::push
  prmerge::clean
}

# Read the config variables used by this script. Set them with:
# git config pr.merge.delete-remote-branch true
# git config --local pr.merge.title-prefix ''
# git config --global pr.merge.sleep-time-before-delete 10

title_prefix='âœ¨ '
delete_remote_branch='true'
sleep_time_before_delete='15'

prmerge::read_config() {
  prmerge::_migrate_config
  prmerge::_get_config title_prefix title-prefix
  prmerge::_get_config delete_remote_branch delete-remote-branch
  prmerge::_get_config sleep_time_before_delete sleep-time-before-delete
}

prmerge::setup() {
  if ! command -v hub >/dev/null; then
    printf 'You need to install hub (https://github.com/github/hub)\n' >&2
    return 1
  fi

  if ! feature=$(git symbolic-ref --short --quiet HEAD); then
    printf 'Not on a branch. Ignoring.\n' >&2
    return 1
  fi

  if ! master=$(hub pr show -f '%B' -h "${feature}"); then
    printf 'Cannot get base branch for pull request. Is there a PR?\n' >&2
    return 1
  fi
}

prmerge::prepare() {
  echo merging "${feature}" to "${master}"

  # Fetch from all remotes so we can check if local branch is up-to-date
  git remote update >/dev/null

  if [[ "$(git rev-parse "${master}")" != "$(git rev-parse "${master}@{upstream}")" ]]; then
    printf '%s is not up-to-date. You should run:\n' "${master}" >&2
    printf '  git checkout %s\n' "${master}" >&2
    printf '  git pull\n' >&2
    return 1
  fi

  # cd to root of repo as master may not contain CWD, but switch back
  # when we're done.
  # shellcheck disable=SC2064
  # We want to evaluate $(pwd) now and not later.
  trap "cd \"$(pwd)\"" EXIT
  cd "$(git rev-parse --show-toplevel)"

  git checkout -q "${master}"
}

prmerge::merge() {
  #open 'https://gist.github.com/rxaviers/7360908'
  #open 'https://gitmoji.carloscuesta.me'

  merge_message="$(prmerge::_merge_message "${feature}" "${master}")"
  if ! git merge --edit --no-ff -m "${merge_message}" "${feature}"; then
    printf 'merge aborted\n' >&2
    git merge --abort
    git checkout -q "${feature}"
    return 1
  fi
}

prmerge::push() {
  git push # push merge (closes PR)
}

prmerge::clean() {
  git branch -d "${feature}" # delete local branch

  if [[ "${delete_remote_branch}" == 'true' ]]; then

    # Allow a delay before deleting the remote branch as some syncing programs
    # try to sync the merge commit and the branch deletion in parallel, leaving
    # one to fail, mucking up the github status.
    if (( sleep_time_before_delete > 0 )); then
      printf 'Waiting before deleting remote branch (%s)...\n' "${sleep_time_before_delete}"
      sleep "${sleep_time_before_delete}"
    fi

    if remote=$(git rev-parse --abbrev-ref --symbolic-full-name '@{u}' 2>/dev/null); then
      remote=${remote%%/*}  # strip off branch name
    else
      remote='origin'  # default if tracking not set
    fi
    if ! git push "${remote}" --delete "${feature}"; then
      echo 'Perhaps GitHub already deleted the branch? Disable deletion with:'
      echo 'git config pr.merge.delete-remote-branch false'
    fi
  fi
}

prmerge::_migrate_config() {
  git config --local --rename-section merge-pr pr.merge 2>/dev/null || true
  git config --global --rename-section merge-pr pr.merge 2>/dev/null || true
}

prmerge::_get_config() {
  local var="$1" name="$2"
  local val
  if val=$(git config --get pr.merge."${name}"); then
    eval "${var}='${val}'"
  fi
}

prmerge::_merge_message() {
  local from_branch="$1"
  local to_branch="$2"
  # Create default merge log message by making a title prefix (from config),
  # title from the PR title and the PR number, then adding a short log of
  # what is being merged and add a diff stat of the files changed by the merge.
  title="$(hub pr show -f '%t' -h "${from_branch}")"
  pr_num="$(hub pr show -f '%I' -h "${from_branch}")"
  pr_url="$(hub pr show -f '%U' -h "${from_branch}")"

cat <<EOF
${title_prefix}${title} (#${pr_num})
$(prmerge::_pr_message "${from_branch}")

This merges the following commits:
$(git log --reverse --pretty=tformat:"* %s" "${to_branch}..${from_branch}")

$(git diff --no-color --stat=72 "${to_branch}...${from_branch}" | sed 's/^/    /')

Pull-Request: ${pr_url}

# Gitmoji: https://gitmoji.carloscuesta.me
# rxaviers list: https://gist.github.com/rxaviers/7360908
#
EOF
}

prmerge::_pr_message() {
  local from_branch="$1"
  echo
  hub pr show -f '%b' -h "${from_branch}" \
  | tr -d \\015 \
  | awk "${markdown_for_commit_awk}"
}

# shellcheck disable=SC2016
# We don't want to expand to expand expressions, so single quotes.
markdown_for_commit_awk='
# print_heading converts a heading starting with a hash to one with an
# underline, as a line starting with a hash in a git commit message is
# ignored.
function print_heading(line)
{
  level1heading = match(line, /^# /) != 0
  sub(/^##* /, "", line)
  marker = level1heading ? "=" : "-"
  printf("%s\n", line)
  for (i = 0; i < length(line); i++)
    printf marker
  printf "\n"
}

# If we want a blank and the current line is not blank, inject a blank line.
/\S/ && want_blank { print "" }
{ want_blank = 0 }

# Lines starting with one or more hashes, followed by a space and one more
# char at least are headings. Convert to underline headings.
/^##* .+/ { print_heading($0); next }

# Convert triple-backtick code blocks to indented code blocks. Ensure there
# is a blank line before and after the block, but dont add extra unnecessary
# blank lines.
/^\s*```/ {
  in_code_block = !in_code_block
  want_blank = !last_blank
  next
}

# Print other lines, indenting code blocks
{
  last_blank = (gsub(/^\s*$/, "") > 0)
  printf("%s%s\n", in_code_block ? "    " : "", $0)
}'

[[ "$(caller)" != 0\ * ]] || main "$@" # Run main if file not sourced
