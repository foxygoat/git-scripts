#!/bin/bash
# vim: set ts=8 sw=2 sts=2 et sta fileencoding=utf-8:
#
# Merge the current branch/PR to master (or $1 if we are already on master)
# with a merge log message I like, push it, delete the local branch and
# delete the remote branch.
#
# It is meant to be done when we have approval to merge and to do the
# merge and subsequent cleanup, from the command line.
#
# This works even if you disable pushing directly to master as github is
# smart enough to recognise the push is pushing a merge, and if that merge
# is valid (because the PR is approved), it allows it and closes the PR.
#
# Usage: git merge-pr [branch]
# If <branch> is present, that branch will be merged into the current branch.
# If <branch> is omitted, the current branch will be merged into master.

main() {
  set -e
  set -u
  set -o pipefail

  mergepr::setup "$@"
  mergepr::prepare
  mergepr::merge
  mergepr::push
  mergepr::clean
}

mergepr::setup() {
  if ! command -v hub >/dev/null; then
    printf 'You need to install hub (https://github.com/github/hub)\n' >&2
    return 1
  fi

  if ! original_branch=$(git symbolic-ref --short --quiet HEAD); then
    printf 'Not on a branch. Ignoring.\n' >&2
    return 1
  fi

  # If given an argument, merge from that branch to the current branch.
  # Otherwise merge from the current branch into master.
  if [[ -n "${1:-}" ]]; then
    merge_from_branch="$1"
    merge_to_branch="${original_branch}"
    pr_show_args=(-h "${merge_from_branch}")
  else
    merge_from_branch="${original_branch}"
    merge_to_branch='master'
    pr_show_args=()
  fi

  if [[ "${merge_from_branch}" == 'master' ]]; then
    printf "Don't be silly. You're never done with master.\n"
    return 1
  fi

  if ! pr_url=$(hub pr show -u ${pr_show_args:+"${pr_show_args[@]}"}); then
    printf 'Cannot get URL for pull request. Is there one?\n' >&2
    return 1
  fi

  switch_needed=false
  if [[ "${original_branch}" != "${merge_to_branch}" ]]; then
    switch_needed=true
  fi
}

mergepr::prepare() {
  echo merging "${merge_from_branch}" to "${merge_to_branch}"

  # Fetch from all remotes so we can check if local branch is up-to-date
  git remote update >/dev/null

  if [[ "$(git rev-parse "${merge_to_branch}")" != "$(git rev-parse "${merge_to_branch}@{upstream}")" ]]; then
    printf '%s is not up-to-date. You should run:\n' "${merge_to_branch}" >&2
    if "${switch_needed}"; then
      printf '  git checkout %s\n' "${merge_to_branch}" >&2
    fi
    printf '  git pull\n' >&2
    return 1
  fi

  if "${switch_needed}"; then
    git checkout -q "${merge_to_branch}"
  fi
}

mergepr::merge() {
  #open 'https://gist.github.com/rxaviers/7360908'
  #open 'https://gitmoji.carloscuesta.me'

  if ! git merge --edit --no-ff -m "$(mergepr::_merge_message)" "${merge_from_branch}"; then
    printf 'merge aborted\n' >&2
    git merge --abort
    if "${switch_needed}"; then
      git checkout -q "${original_branch}"
    fi
    return 1
  fi
}

mergepr::push() {
  git push # push merge (closes PR)
}

mergepr::clean() {
  git branch -d "${merge_from_branch}" # delete local branch
  # Wait before deleting branch, otherwise two gitsyncs run in parallel (the
  # merge commit and the branch delete), and one fails due to repo locking
  # on the remote end. This causes a spurious X as a bad commit check in github.
  printf 'Waiting before deleting remote branch (15s)...\n'
  sleep 15
  # TODO(camh): figure out how to determine remote instead of assuming 'origin'
  git push origin -d "${merge_from_branch}" # delete remote branch
}

mergepr::_merge_message() {
  # Create default merge log message by making a title from the branch name,
  # a gitmoji, and the PR number, then adding a short log of what's
  # being merged and add a diff stat of the files changed by the merge.
  gitmoji=':sparkles:'
  title="${merge_from_branch#feature/}" # strip of leading "feature/"
  title="${title//[-_]/ }" # convert _ and - to spaces
  pr_num="${pr_url##*/}"
cat <<EOF
${gitmoji} Merge ${title} (#${pr_num})
$(mergepr::_pr_message)

$(git log --reverse --pretty=tformat:"* %s" "..${merge_from_branch}")

$(git diff --no-color --stat "...${merge_from_branch}")

# Gitmoji: https://gitmoji.carloscuesta.me
# rxaviers list: https://gist.github.com/rxaviers/7360908
#
EOF
}

mergepr::_pr_message() {
  echo
  hub pr list -h "${merge_from_branch}" -f '%b' \
  | awk "${markdown_for_commit_awk}"
}

markdown_for_commit_awk='
# print_heading converts a heading starting with a hash to one with an
# underline, as a line starting with a hash in a git commit message is
# ignored.
function print_heading(line)
{
  match(line, /^(##*) (.+)/, groups)
  marker = length(groups[1]) == 1 ? "=" : "-"
  heading = groups[2]
  printf("%s\n", heading)
  for (i = 0; i < length(heading); i++)
    printf marker
  printf "\n"
}

# If we want a blank and the current line is not blank, inject a blank line.
/\S/ && want_blank { print "" }
{ want_blank = 0 }

# Lines starting with one or more hashes, followed by a space and one more
# char at least are headings. Convert to underline headings.
/^##* .+/ { print_heading($0); next }

# Convert triple-backtick code blocks to indented code blocks. Ensure there
# is a blank line before and after the block, but dont add extra unnecessary
# blank lines.
/^\s*```/ {
  in_code_block = !in_code_block
  want_blank = !last_blank
  next
}

# Print other lines, indenting code blocks
{
  last_blank = (gsub(/^\s*$/, "") > 0)
  printf("%s%s\n", in_code_block ? "    " : "", $0)
}'

[[ "$(caller)" != 0\ * ]] || main "$@" # Run main if file not sourced
